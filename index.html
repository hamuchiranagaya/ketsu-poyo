<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>はむケツ ぷよ風 落ちゲー 試作</title>
  <style>
    html,body{margin:0;padding:0;background:#0b0b10;color:#fff;font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Hiragino Sans',sans-serif}
    #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
    canvas{background:#111;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .hud{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap}
    .btnbar{display:grid;grid-template-columns:repeat(3,64px);grid-template-rows:repeat(2,64px);gap:8px;touch-action:manipulation}
    button{border:none;border-radius:12px;padding:12px;background:#222;color:#fff;font-weight:700;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,.25)}
    button:active{transform:translateY(1px);opacity:.9}
    .wide{grid-column:span 3}
    .note{opacity:.85;font-size:12px;text-align:center;line-height:1.4}
    a{color:#86e1ff}
  </style>
</head>
<body>
<div id="wrap">
  <h2>はむケツ ぷよ風（試作）</h2>
  <div class="hud">
    <div>スコア: <span id="score">0</span></div>
    <div>チェイン: <span id="chain">0</span></div>
    <div><button id="restart">リスタート</button></div>
  </div>
  <canvas id="game" width="384" height="640"></canvas>
  <div class="btnbar" aria-label="タッチ操作">
    <button id="left">←</button>
    <button id="down">↓</button>
    <button id="right">→</button>
    <button id="rotL">↺</button>
    <button id="drop" class="wide">瞬間落下</button>
    <button id="rotR">↻</button>
  </div>
  <div class="note">
    操作：← → 移動 / ↑ 回転 / ↓ ソフトドロップ / スペース 瞬間落下 / R リスタート<br/>
    画像差し替え：<code>assets/ham_01.png</code> ～ <code>ham_06.png</code> を置くと写真表示になります。
  </div>
</div>
<script>
// はじける演出付き ぷよ風 はむケツ
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  function fit() {
    const scale = Math.min((window.innerWidth-16)/W, (window.innerHeight-220)/H);
    canvas.style.width = (W*scale)+'px';
    canvas.style.height = (H*scale)+'px';
  }
  window.addEventListener('resize', fit); fit();

  const COLS = 6, ROWS = 12;
  const TILE = Math.floor(Math.min(W/COLS, H/ROWS));
  const PX = Math.floor((W - COLS*TILE)/2);
  const PY = Math.floor((H - ROWS*TILE)/2);

  const TYPES = 6;
  const COLORS = ['#f5c6a5','#e0f0ff','#c6d0ff','#ffd9d9','#c0ffc8','#ffe6a8'];

  const images = Array.from({length:TYPES}, (_,i)=> new Image());
  let useImages = false;
  let loadedCount = 0;
  images.forEach((img, i) => {
    img.onload = () => { loadedCount++; if (loadedCount===TYPES) { useImages = true; } };
    img.onerror = () => {};
    img.src = `assets/ham_${String(i+1).padStart(2,'0')}.png`;
  });

  let grid, falling, nextPair, score, chain;
  const empty = () => ({ type: 0, pop: false, popT: 0 });
  const resetGrid = () => Array.from({length:ROWS},()=>Array.from({length:COLS}, empty));

  // resolve state machine
  let resolving = false;
  let popPhase = 0; // 0 none, 1 animating
  let popTimer = 0;
  let poppedAny = false;
  let localChain = 0;
  let particles = [];

  function newPair() {
    return { cx: Math.floor(COLS/2), cy: -1,
      blocks: [{dx:0, dy:0, type: randType()},{dx:0, dy:-1, type: randType()}],
      rot: 0 };
  }
  function randType(){ return 1 + (Math.random()*TYPES|0); }

  function restart() {
    grid = resetGrid(); score = 0; chain = 0;
    particles = [];
    falling = newPair(); nextPair = newPair();
    resolving = false; popPhase = 0; poppedAny = false; localChain = 0; popTimer = 0;
    updateHUD();
  }
  function updateHUD(){
    document.getElementById('score').textContent = score;
    document.getElementById('chain').textContent = chain;
  }

  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code]=true; if (['ArrowUp','Space','KeyR'].includes(e.code)) e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.code]=false; });

  const bindBtn = (id, fn) => {
    const el = document.getElementById(id);
    let t;
    const press = () => { fn(); t = setInterval(fn, 120); };
    const release = () => { clearInterval(t); };
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); press(); });
    el.addEventListener('touchend', (e)=>{ e.preventDefault(); release(); });
    el.addEventListener('mousedown', press);
    el.addEventListener('mouseup', release);
    el.addEventListener('mouseleave', release);
  };
  bindBtn('left', ()=> move(-1));
  bindBtn('right',()=> move(1));
  bindBtn('down', ()=> softDrop());
  bindBtn('rotL', ()=> rotate(-1));
  bindBtn('rotR', ()=> rotate(1));
  bindBtn('drop', ()=> hardDrop());
  document.getElementById('restart').onclick = ()=> restart();

  function move(dx){ if (!falling || resolving) return; if (canMove(falling, dx, 0)) falling.cx += dx; }
  function softDrop(){ if (!falling || resolving) return; if (canMove(falling, 0, 1)) falling.cy += 1; else lock(); }
  function hardDrop(){
    if (!falling || resolving) return;
    while (canMove(falling, 0, 1)) falling.cy += 1;
    lock();
  }
  function rotate(dir){
    if (!falling || resolving) return;
    const next = (falling.rot + dir + 4) % 4;
    const nb = orient(next, falling.blocks[0].type, falling.blocks[1].type);
    const tmp = { ...falling, blocks: nb, rot: next };
    if (canMove(tmp, 0, 0)) { falling.blocks = nb; falling.rot = next; }
  }
  function orient(rot, t0, t1){
    const b0 = {dx:0, dy:0, type:t0};
    const b1 = {dx:0, dy:-1, type:t1};
    if (rot===1){ b1.dx=1; b1.dy=0; }
    if (rot===2){ b1.dx=0; b1.dy=1; }
    if (rot===3){ b1.dx=-1; b1.dy=0; }
    return [b0,b1];
  }
  function canMove(pair, dx, dy){
    for (const b of pair.blocks){
      const x = pair.cx + b.dx + dx;
      const y = pair.cy + b.dy + dy;
      if (x<0 || x>=COLS || y>=ROWS) return false;
      if (y>=0 && grid[y][x].type) return false;
    }
    return true;
  }

  function lock(){
    for (const b of falling.blocks){
      const x = falling.cx + b.dx, y = falling.cy + b.dy;
      if (y<0){ restart(); return; }
      grid[y][x] = { type: b.type, pop: false, popT: 0 };
    }
    falling = null;
    resolving = true; popPhase = 0; poppedAny = false; localChain = 0;
  }

  function resolveScan(){
    // reset marks
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){ grid[r][c].pop=false; grid[r][c].popT=0; }
    const visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    function bfs(sr, sc){
      const t = grid[sr][sc].type;
      const q=[[sr,sc]]; visited[sr][sc]=true;
      const cells=[[sr,sc]];
      while(q.length){
        const [r,c]=q.shift();
        for(const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc;
          if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS&&!visited[nr][nc]&&grid[nr][nc].type===t){
            visited[nr][nc]=true; q.push([nr,nc]); cells.push([nr,nc]);
          }
        }
      }
      return cells;
    }
    let found = 0;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if(!visited[r][c] && grid[r][c].type){
          const cells = bfs(r,c);
          if (cells.length>=4){
            found += cells.length;
            cells.forEach(([rr,cc])=> { grid[rr][cc].pop = true; grid[rr][cc].popT = 0; spawnBurst(PX+cc*TILE+TILE/2, PY+rr*TILE+TILE/2, grid[rr][cc].type); });
          }
        }
      }
    }
    if (found>0){
      popPhase = 1; popTimer = 0; poppedAny = true; localChain++;
    } else {
      // 終了：次のペアを落とす
      resolving = false;
      chain = poppedAny ? localChain : 0;
      updateHUD();
      falling = nextPair; nextPair = newPair();
    }
  }

  function spawnBurst(x, y, type){
    const N = 10;
    for (let i=0;i<N;i++){
      const a = Math.random()*Math.PI*2;
      const v = 1.5 + Math.random()*3.5;
      particles.push({
        x, y,
        vx: Math.cos(a)*v,
        vy: Math.sin(a)*v - 1.5,
        life: 0,
        max: 450 + Math.random()*250,
        type
      });
    }
  }

  function updateParticles(dt){
    const g = 0.005;
    particles.forEach(p => {
      p.life += dt;
      p.x += p.vx * dt*0.06;
      p.y += p.vy * dt*0.06;
      p.vy += g * dt;
    });
    particles = particles.filter(p => p.life < p.max);
  }

  function performClearAndGravity(){
    let cleared=0;
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      if (grid[r][c].pop){ grid[r][c] = empty(); cleared++; }
    }
    if (cleared>0){
      const add = cleared*10 * (localChain>1? localChain : 1);
      score += add; updateHUD();
    }
    // gravity
    for (let c=0;c<COLS;c++){
      let write = ROWS-1;
      for (let r=ROWS-1;r>=0;r--){
        if (grid[r][c].type){
          if (r!==write){ grid[write][c]=grid[r][c]; grid[r][c]=empty(); }
          write--;
        }
      }
    }
  }

  function drawBlob(x,y,size,type, scale=1, alpha=1){
    ctx.save();
    ctx.globalAlpha = alpha;
    const cx = x + size/2, cy = y + size/2;
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.translate(-cx, -cy);
    if (useImages){
      const img = images[(type-1)%images.length];
      ctx.drawImage(img, x, y, size, size);
      ctx.restore();
      return;
    }
    const r=size*0.45;
    const grad = ctx.createRadialGradient(cx-r*0.4, cy-r*0.4, r*0.2, cx, cy, r);
    const base = COLORS[(type-1)%COLORS.length];
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.15, base);
    grad.addColorStop(1, '#333');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath();
    ctx.arc(cx+r*0.45, cy+r*0.1, r*0.18, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawParticles(){
    for (const p of particles){
      const a = 1 - (p.life / p.max);
      const s = 0.5 + 0.7*a;
      const size = Math.max(10, TILE*0.5*s);
      ctx.save();
      ctx.globalAlpha = Math.max(0, a);
      ctx.fillStyle = COLORS[(p.type-1)%COLORS.length];
      ctx.beginPath();
      ctx.arc(p.x, p.y, size*0.12, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function update(dt){
    // input (single-fire)
    if (keys['ArrowLeft']){ move(-1); keys['ArrowLeft']=false; }
    if (keys['ArrowRight']){ move(1); keys['ArrowRight']=false; }
    if (keys['ArrowDown']){ softDrop(); keys['ArrowDown']=false; }
    if (keys['ArrowUp']){ rotate(1); keys['ArrowUp']=false; }
    if (keys['Space']){ hardDrop(); keys['Space']=false; }
    if (keys['KeyR']){ restart(); keys['KeyR']=false; }

    updateParticles(dt);

    if (resolving){
      if (popPhase===0){
        // 探索して、消える対象があればアニメ開始
        resolveScan();
      } else if (popPhase===1){
        // ポップ演出：スケールアップ→フェード（200ms）
        popTimer += dt;
        const D = 220;
        for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
          const cell = grid[r][c];
          if (cell.pop){ cell.popT = Math.min(1, popTimer/D); }
        }
        if (popTimer >= D){
          // 実際に消して重力、その後また探索へ
          performClearAndGravity();
          popPhase = 0; popTimer = 0;
        }
      }
      return;
    }

    // normal fall
    dropTimer += dt;
    const fallInterval = Math.max(150, 800 - Math.floor(score/200)*30);
    if (dropTimer >= fallInterval){
      dropTimer = 0;
      if (falling){
        if (canMove(falling, 0, 1)) falling.cy += 1;
        else lock();
      }
    }
  }

  let dropTimer = 0;
  function draw(){
    // bg
    ctx.fillStyle = '#0f1220';
    ctx.fillRect(0,0,W,H);

    // grid
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const cell = grid[r][c];
        if (cell.type){
          let scale=1, alpha=1;
          if (cell.pop){
            // scale up & fade
            scale = 1 + 0.35*cell.popT;
            alpha = 1 - 0.65*cell.popT;
          }
          drawBlob(PX+c*TILE, PY+r*TILE, TILE, cell.type, scale, alpha);
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.04)';
          ctx.fillRect(PX+c*TILE+1, PY*r*TILE+1, TILE-2, TILE-2);
        }
      }
    }

    // falling
    if (falling){
      for (const b of falling.blocks){
        const x = falling.cx + b.dx, y = falling.cy + b.dy;
        if (y>=0) drawBlob(PX+x*TILE, PY+y*TILE, TILE, b.type);
      }
    }

    // frame & particles
    ctx.strokeStyle = 'rgba(255,255,255,.2)';
    ctx.lineWidth = 2;
    ctx.strokeRect(PX-2, PY-2, COLS*TILE+4, ROWS*TILE+4);

    drawParticles();
  }

  let last=performance.now();
  function loop(now){
    const dt = now - last; last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  restart();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
