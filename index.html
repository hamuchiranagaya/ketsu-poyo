<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>はむケツぽよぽよ（試作・SFX）</title>
  <style>
    html,body{margin:0;padding:0;background:#0b0b10;color:#fff;font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Hiragino Sans',sans-serif}
    #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
    canvas{background:#111;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .hud{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap}
    .btnbar{display:grid;grid-template-columns:repeat(3,64px);grid-template-rows:repeat(2,64px);gap:8px;touch-action:manipulation}
    button{border:none;border-radius:12px;padding:12px;background:#222;color:#fff;font-weight:700;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,.25)}
    button:active{transform:translateY(1px);opacity:.9}
    .wide{grid-column:span 3}
    .note{opacity:.85;font-size:12px;text-align:center;line-height:1.4;max-width:560px}
    a{color:#86e1ff}
  </style>
</head>
<body>
<div id="wrap">
  <h2>はむケツぽよぽよ（試作）</h2>
  <div class="hud">
    <div>スコア: <span id="score">0</span></div>
    <div>チェイン: <span id="chain">0</span></div>
    <div><button id="restart">リスタート</button></div>
  </div>
  <canvas id="game" width="384" height="640"></canvas>
  <div class="btnbar" aria-label="タッチ操作">
    <button id="left">←</button>
    <button id="down">↓</button>
    <button id="right">→</button>
    <button id="rotL">↺</button>
    <button id="drop" class="wide">瞬間落下</button>
    <button id="rotR">↻</button>
  </div>
  <div class="note">
    操作：← → 移動 / ↑ 回転 / ↓ ソフトドロップ / スペース 瞬間落下 / R リスタート<br/>
    画像差し替え：<code>assets/ham_01.png</code> ～ <code>ham_06.png</code> を置くと写真表示になります（任意）。
  </div>
</div>
<script>
// はむケツぽよぽよ — ぷるぷる→バン！演出＋かわいいSFX
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  function fit() {
    const scale = Math.min((window.innerWidth-16)/W, (window.innerHeight-220)/H);
    canvas.style.width = (W*scale)+'px';
    canvas.style.height = (H*scale)+'px';
  }
  window.addEventListener('resize', fit); fit();

  // --------- Cute SFX (WebAudio synth, no external files) ---------
  let actx;
  function ensureAudio(){ if(!actx){ actx = new (window.AudioContext||window.webkitAudioContext)(); } }
  function env(t0, dur, attack, decay){
    const g = actx.createGain();
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(1, t0+attack);
    g.gain.exponentialRampToValueAtTime(0.001, t0+attack+decay);
    return g;
  }
  function sfxPoyo(){
    if(!actx) return;
    const t = actx.currentTime + 0.01;
    const o = actx.createOscillator();
    const g = env(t, .12, .01, .12);
    o.type = 'sine';
    o.frequency.setValueAtTime(720, t);
    o.frequency.exponentialRampToValueAtTime(540, t+0.12);
    o.connect(g).connect(actx.destination);
    o.start(t); o.stop(t+0.2);
    // tiny second bounce
    const o2 = actx.createOscillator();
    const g2 = env(t+0.08, .1, .005, .1);
    o2.type = 'sine';
    o2.frequency.setValueAtTime(600, t+0.08);
    o2.frequency.exponentialRampToValueAtTime(480, t+0.18);
    o2.connect(g2).connect(actx.destination);
    o2.start(t+0.08); o2.stop(t+0.2);
  }
  function sfxPop(){
    if(!actx) return;
    const t = actx.currentTime + 0.01;
    // white noise burst + sine blip
    const bufferSize = actx.sampleRate * 0.08;
    const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * (1 - i/bufferSize); }
    const src = actx.createBufferSource(); src.buffer = buffer;
    const g = env(t, .12, .001, .12);
    src.connect(g).connect(actx.destination);
    src.start(t);
    const o = actx.createOscillator(); o.type='sine';
    o.frequency.setValueAtTime(520, t);
    o.frequency.exponentialRampToValueAtTime(260, t+0.12);
    const g2 = env(t, .12, .001, .12);
    o.connect(g2).connect(actx.destination);
    o.start(t); o.stop(t+0.15);
  }
  // Tap to enable audio on mobile
  window.addEventListener('pointerdown', ()=>{ ensureAudio(); }, {once:true});

  // --------- Game core ---------
  const COLS = 6, ROWS = 12;
  const TILE = Math.floor(Math.min(W/COLS, H/ROWS));
  const PX = Math.floor((W - COLS*TILE)/2);
  const PY = Math.floor((H - ROWS*TILE)/2);

  const TYPES = 6;
  const COLORS = ['#f5c6a5','#e0f0ff','#c6d0ff','#ffd9d9','#c0ffc8','#ffe6a8'];

  const images = Array.from({length:TYPES}, (_,i)=> new Image());
  let useImages = false;
  let loadedCount = 0;
  images.forEach((img, i) => {
    img.onload = () => { loadedCount++; if (loadedCount===TYPES) useImages = true; };
    img.onerror = () => {};
    img.src = 'assets/ham_' + String(i+1).padStart(2,'0') + '.png';
  });

  let grid, falling, nextPair, score, chain;
  const empty = () => ({ type: 0, mark: false, t: 0, seed: 0 });
  const resetGrid = () => Array.from({length:ROWS},()=>Array.from({length:COLS}, empty));

  // resolve phases: 0 scan, 1 shake (120ms), 2 pop (220ms)
  let resolving = false;
  let phase = 0;
  let timer = 0;
  let poppedAny = false;
  let localChain = 0;
  let particles = [];

  function newPair() {
    return { cx: Math.floor(COLS/2), cy: -1,
      blocks: [{dx:0, dy:0, type: rType()},{dx:0, dy:-1, type: rType()}],
      rot: 0 };
  }
  const rType = () => 1 + (Math.random()*TYPES|0);

  function restart() {
    grid = resetGrid(); score = 0; chain = 0;
    particles = [];
    falling = newPair(); nextPair = newPair();
    resolving = false; phase = 0; timer = 0; poppedAny = false; localChain = 0;
    updHUD();
  }
  function updHUD(){
    document.getElementById('score').textContent = score;
    document.getElementById('chain').textContent = chain;
  }

  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code]=true; if (['ArrowUp','Space','KeyR'].includes(e.code)) e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.code]=false; });

  const bindBtn = (id, fn) => {
    const el = document.getElementById(id);
    let t;
    const press = () => { fn(); t = setInterval(fn, 120); };
    const release = () => { clearInterval(t); };
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); fn(); });
    el.addEventListener('touchend', (e)=>{ e.preventDefault(); });
    el.addEventListener('mousedown', press);
    el.addEventListener('mouseup', release);
    el.addEventListener('mouseleave', release);
  };
  bindBtn('left', ()=> move(-1));
  bindBtn('right',()=> move(1));
  bindBtn('down', ()=> sDrop());
  bindBtn('rotL', ()=> rot(-1));
  bindBtn('rotR', ()=> rot(1));
  bindBtn('drop', ()=> hDrop());
  document.getElementById('restart').onclick = ()=> restart();

  function move(dx){ if (!falling || resolving) return; if (can(falling, dx, 0)) falling.cx += dx; }
  function sDrop(){ if (!falling || resolving) return; if (can(falling, 0, 1)) falling.cy += 1; else lock(); }
  function hDrop(){
    if (!falling || resolving) return;
    while (can(falling, 0, 1)) falling.cy += 1;
    lock();
  }
  function rot(dir){
    if (!falling || resolving) return;
    const next = (falling.rot + dir + 4) % 4;
    const nb = orient(next, falling.blocks[0].type, falling.blocks[1].type);
    const tmp = { ...falling, blocks: nb, rot: next };
    if (can(tmp, 0, 0)) { falling.blocks = nb; falling.rot = next; }
  }
  function orient(rot, t0, t1){
    const b0 = {dx:0, dy:0, type:t0};
    const b1 = {dx:0, dy:-1, type:t1};
    if (rot===1){ b1.dx=1; b1.dy=0; }
    if (rot===2){ b1.dx=0; b1.dy=1; }
    if (rot===3){ b1.dx=-1; b1.dy=0; }
    return [b0,b1];
  }
  function can(pair, dx, dy){
    for (const b of pair.blocks){
      const x = pair.cx + b.dx + dx;
      const y = pair.cy + b.dy + dy;
      if (x<0 || x>=COLS || y>=ROWS) return false;
      if (y>=0 && grid[y][x].type) return false;
    }
    return true;
  }

  function lock(){
    for (const b of falling.blocks){
      const x = falling.cx + b.dx, y = falling.cy + b.dy;
      if (y<0){ restart(); return; }
      grid[y][x] = { type: b.type, mark: false, t: 0, seed: Math.random()*1000 };
    }
    falling = null;
    resolving = true; phase = 0; timer = 0; poppedAny = false; localChain = 0;
  }

  function scan(){
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){ grid[r][c].mark=false; grid[r][c].t=0; }
    const vis = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    const q=[];
    function bfs(sr, sc){
      const t = grid[sr][sc].type;
      q.length=0; q.push([sr,sc]); vis[sr][sc]=true;
      const cells=[[sr,sc]];
      while(q.length){
        const [r,c]=q.shift();
        for(const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc;
          if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS&&!vis[nr][nc]&&grid[nr][nc].type===t){
            vis[nr][nc]=true; q.push([nr,nc]); cells.push([nr,nc]);
          }
        }
      }
      return cells;
    }
    let found = 0;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if(!vis[r][c] && grid[r][c].type){
          const cells = bfs(r,c);
          if (cells.length>=4){
            found += cells.length;
            cells.forEach(([rr,cc])=>{ grid[rr][cc].mark = true; spawnBurst(PX+cc*TILE+TILE/2, PY+rr*TILE+TILE/2, grid[rr][cc].type); });
          }
        }
      }
    }
    if (found>0){ phase = 1; timer = 0; poppedAny = true; localChain++; sfxPoyo(); }
    else { // no pops
      resolving = false;
      chain = poppedAny ? localChain : 0; updHUD();
      falling = nextPair; nextPair = newPair();
    }
  }

  function spawnBurst(x, y, type){
    const N = 10;
    for (let i=0;i<N;i++){
      const a = Math.random()*Math.PI*2;
      const v = 1.5 + Math.random()*3.5;
      particles.push({
        x, y,
        vx: Math.cos(a)*v,
        vy: Math.sin(a)*v - 1.5,
        life: 0,
        max: 450 + Math.random()*250,
        type
      });
    }
  }
  function updParticles(dt){
    const g = 0.005;
    particles.forEach(p => {
      p.life += dt;
      p.x += p.vx * dt*0.06;
      p.y += p.vy * dt*0.06;
      p.vy += g * dt;
    });
    particles = particles.filter(p => p.life < p.max);
  }

  function clearAndFall(){
    let cleared=0;
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      if (grid[r][c].mark){ grid[r][c] = empty(); cleared++; }
    }
    if (cleared>0){
      const add = cleared*10 * (localChain>1? localChain : 1);
      score += add; updHUD();
      sfxPop();
    }
    for (let c=0;c<COLS;c++){ // gravity
      let w = ROWS-1;
      for (let r=ROWS-1;r>=0;r--){
        if (grid[r][c].type){
          if (r!==w){ grid[w][c]=grid[r][c]; grid[r][c]=empty(); }
          w--;
        }
      }
    }
  }

  function drawBlob(x,y,size,type, scale=1, alpha=1, shakeX=0, shakeY=0){
    ctx.save();
    ctx.globalAlpha = alpha;
    const cx = x + size/2 + shakeX, cy = y + size/2 + shakeY;
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.translate(-cx, -cy);
    if (useImages){
      const img = images[(type-1)%images.length];
      ctx.drawImage(img, x+shakeX, y+shakeY, size, size);
      ctx.restore();
      return;
    }
    const r=size*0.45;
    const grad = ctx.createRadialGradient(cx-r*0.4, cy-r*0.4, r*0.2, cx, cy, r);
    const base = COLORS[(type-1)%COLORS.length];
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.15, base);
    grad.addColorStop(1, '#333');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath();
    ctx.arc(cx+r*0.45, cy+r*0.1, r*0.18, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawParticles(){
    for (const p of particles){
      const a = 1 - (p.life / p.max);
      const s = 0.5 + 0.7*a;
      const size = Math.max(10, TILE*0.5*s);
      ctx.save();
      ctx.globalAlpha = Math.max(0, a);
      ctx.fillStyle = COLORS[(p.type-1)%COLORS.length];
      ctx.beginPath();
      ctx.arc(p.x, p.y, size*0.12, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  let dropTimer = 0;
  function update(dt){
    if (keys['ArrowLeft']){ move(-1); keys['ArrowLeft']=false; }
    if (keys['ArrowRight']){ move(1); keys['ArrowRight']=false; }
    if (keys['ArrowDown']){ sDrop(); keys['ArrowDown']=false; }
    if (keys['ArrowUp']){ rot(1); keys['ArrowUp']=false; }
    if (keys['Space']){ hDrop(); keys['Space']=false; }
    if (keys['KeyR']){ restart(); keys['KeyR']=false; }

    updParticles(dt);

    if (resolving){
      if (phase===0){ scan(); return; }
      timer += dt;
      if (phase===1){ if (timer >= 120){ phase = 2; timer = 0; } return; }
      if (phase===2){ if (timer >= 220){ clearAndFall(); phase = 0; timer = 0; } return; }
    } else {
      dropTimer += dt;
      const fallInt = Math.max(150, 800 - Math.floor(score/200)*30);
      if (dropTimer >= fallInt){
        dropTimer = 0;
        if (falling){
          if (can(falling, 0, 1)) falling.cy += 1;
          else lock();
        }
      }
    }
  }

  function draw(){
    ctx.fillStyle = '#0f1220'; ctx.fillRect(0,0,W,H);
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const cell = grid[r][c];
        if (cell.type){
          let scale=1, alpha=1, sx=0, sy=0;
          if (cell.mark){
            if (phase===1){
              const amp = TILE*0.06;
              const t = (timer + cell.seed*13.37) * 0.05;
              sx = Math.sin(t)*amp;
              sy = Math.cos(t*1.3)*amp;
            }
            if (phase===2){
              const p = Math.min(1, timer/220);
              scale = 1 + 0.35*p;
              alpha = 1 - 0.65*p;
            }
          }
          drawBlob(PX+c*TILE, PY+r*TILE, TILE, cell.type, scale, alpha, sx, sy);
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.04)';
          ctx.fillRect(PX+c*TILE+1, PY*r*TILE+1, TILE-2, TILE-2);
        }
      }
    }
    if (falling){
      for (const b of falling.blocks){
        const x = falling.cx + b.dx, y = falling.cy + b.dy;
        if (y>=0) drawBlob(PX+x*TILE, PY+y*TILE, TILE, b.type);
      }
    }
    ctx.strokeStyle = 'rgba(255,255,255,.2)'; ctx.lineWidth = 2;
    ctx.strokeRect(PX-2, PY-2, COLS*TILE+4, ROWS*TILE+4);
    drawParticles();
  }

  function loop(now){
    const dt = now - (loop.last||now); loop.last = now;
    update(dt); draw();
    requestAnimationFrame(loop);
  }
  restart();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
