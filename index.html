<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>ã¯ã‚€ã‚±ãƒ„ã½ã‚ˆã½ã‚ˆ</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4facfe">
  <link rel="icon" href="ketsupoyo.png" type="image/png">
  <style>
    :root{--bg:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);--panel:#2a3f5f;--fg:#fff;--muted:#b8c6db;--btn:#34495e;--accent:#f39c12;--card-bg:#34495e;}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Hiragino Sans',sans-serif;min-height:100vh}
    body{background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)}
    #wrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:12px 8px}
    header{display:flex;align-items:center;gap:10px}
    header img{width:40px;height:40px;border-radius:8px;display:none}
    header.ready img{display:block}
    h1, h2{margin:0;font-size:20px;font-weight:800;text-align:center;text-shadow:2px 2px 4px rgba(0,0,0,0.3)}
    h1{font-size:32px;color:#fff}
    canvas{background:var(--panel);border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .hud{display:flex;gap:14px;align-items:center;justify-content:center;flex-wrap:wrap}
    .hud .muted{color:var(--muted)}
    .btnbar{display:flex;justify-content:space-between;gap:4px;width:100%;touch-action:manipulation;flex-wrap:wrap}
    .btnbar > button{flex:1;max-width:19%;height:60px;border:none;border-radius:12px;background:var(--btn);color:var(--fg);font-weight:700;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,.25)}
    .btnbar > button:active{transform:translateY(1px);opacity:.9}
    .btnbar > .wide{flex:1 1 100%;max-width:100%;margin-top:8px}
    .note{opacity:.85;font-size:12px;text-align:center;line-height:1.4;max-width:620px;color:#fff;text-shadow:1px 1px 2px rgba(0,0,0,0.3)}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    .pill{background:rgba(255,255,255,0.2);border-radius:999px;padding:6px 10px;font-size:12px;cursor:pointer;border:none;color:var(--fg);backdrop-filter:blur(10px)}
    .pill:hover{background:rgba(255,255,255,0.3)}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;padding:16px;z-index:1000}
    .card{background:var(--card-bg);border:1px solid rgba(255,255,255,0.1);border-radius:14px;max-width:520px;width:96%;padding:16px;box-shadow:0 12px 32px rgba(0,0,0,.4)}
    .card h3{margin:4px 0 10px 0}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .row button{background:rgba(255,255,255,0.1);border:none;border-radius:8px;padding:8px 16px;color:var(--fg);font-weight:600;cursor:pointer}
    .row button:hover{background:rgba(255,255,255,0.2)}
    .scores{display:flex;gap:8px;margin:10px 0}
    .scores span{background:rgba(255,255,255,0.1);border-radius:8px;padding:6px 10px;font-weight:700}
    
    /* ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ */
    .start-screen{text-align:center;padding:20px;background:rgba(255,255,255,0.1);border-radius:20px;margin:20px;backdrop-filter:blur(10px);box-shadow:0 8px 32px rgba(0,0,0,0.2)}
    .start-screen h1{font-size:32px;margin:20px 0;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.3)}
    .app-icon{width:80px;height:80px;border-radius:16px;margin:0 auto 20px auto;display:none;box-shadow:0 4px 16px rgba(0,0,0,0.3)}
    .app-icon.ready{display:block}
    .game-description{font-size:14px;margin:20px 0;color:#fff;line-height:1.6;text-shadow:1px 1px 2px rgba(0,0,0,0.3)}
    .start-btn{background:linear-gradient(135deg,#f39c12,#e67e22);color:#fff;border:none;border-radius:16px;padding:16px 32px;font-size:18px;font-weight:bold;cursor:pointer;box-shadow:0 8px 24px rgba(243,156,18,.3);margin:20px 0;text-shadow:1px 1px 2px rgba(0,0,0,0.3)}
    .start-btn:hover{transform:translateY(-2px);box-shadow:0 12px 32px rgba(243,156,18,.4)}
    .install-section{margin:20px 0;padding:16px;background:rgba(255,255,255,0.1);border-radius:12px;backdrop-filter:blur(10px)}
    .install-btn{background:rgba(255,255,255,0.2);border:2px dashed rgba(255,255,255,0.4);border-radius:12px;padding:12px 20px;cursor:pointer;display:inline-flex;align-items:center;gap:8px;margin:8px 0;color:#fff;backdrop-filter:blur(10px)}
    .install-btn:hover{background:rgba(255,255,255,0.3);border-color:rgba(255,255,255,0.6)}
    .youtube-link{display:block;margin:16px auto;color:var(--accent);font-weight:600;text-shadow:1px 1px 2px rgba(0,0,0,0.3);text-align:center}
    .youtube-link:hover{color:#fff;text-decoration:underline}
    .share-buttons{display:flex;gap:12px;justify-content:center;margin:16px 0}
    .share-btn{background:rgba(255,255,255,0.2);border:none;border-radius:12px;padding:10px 16px;color:#fff;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:6px;backdrop-filter:blur(10px)}
    .share-btn:hover{background:rgba(255,255,255,0.3)}
    .share-btn.x-btn{background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.2)}
    .share-btn.x-btn:hover{background:rgba(0,0,0,0.5)}
    .game-area{display:none}
    .game-area.active{display:flex;flex-direction:column;align-items:center;gap:10px}
  </style>
</head>
<body>
<div id="wrap">
  <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
  <div id="startScreen" class="start-screen">
    <img id="appicon" alt="ã‚¢ãƒ—ãƒªã‚¢ã‚¤ã‚³ãƒ³" class="app-icon"/>
    <h1>ã¯ã‚€ã‚±ãƒ„ã½ã‚ˆã½ã‚ˆ</h1>
    
    <div class="install-section">
      <p>ğŸ“± ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã—ã¦ã‚¢ãƒ—ãƒªã®ã‚ˆã†ã«ä½¿ãˆã¾ã™</p>
      <button id="installBtn" class="install-btn">
        <span>ğŸ“²</span>
        <span>ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ </span>
      </button>
    </div>
    
    <div class="game-description">
      4å€‹ä»¥ä¸Šã®åŒã˜è‰²ã®ã¯ã‚€ã‚±ãƒ„ã‚’ã¤ãªã’ã¦æ¶ˆãã†ï¼<br/>
      é€£é–ã§ã‚¹ã‚³ã‚¢ã‚¢ãƒƒãƒ—ï¼
    </div>
    
    <button id="startBtn" class="start-btn">
      ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ
    </button>
    
    <a href="https://youtube.com/@hamuchira" target="_blank" class="youtube-link">
      ğŸ¬ ã‚‚ã£ã¨ï¼ã¯ã‚€ãƒãƒ©é•·å±‹ch.
    </a>
    
    <div class="share-buttons">
      <button id="shareX" class="share-btn x-btn">
        Xã§ã‚·ã‚§ã‚¢
      </button>
      <button id="copyUrl" class="share-btn">
        <span>ğŸ“‹</span>
        <span>URLã‚³ãƒ”ãƒ¼</span>
      </button>
    </div>
  </div>

  <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
  <div id="gameArea" class="game-area">
    <header>
      <h2>ã¯ã‚€ã‚±ãƒ„ã½ã‚ˆã½ã‚ˆ</h2>
    </header>

    <div class="hud">
      <div>ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
      <div>ãƒã‚§ã‚¤ãƒ³: <span id="chain">0</span></div>
      <div id="timeWrap" class="muted" style="display:none;">æ®‹ã‚Š: <span id="time">180</span>s</div>
      <button id="mode" class="pill" title="åˆ¶é™æ™‚é–“ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿">åˆ¶é™æ™‚é–“:OFF</button>
    </div>

    <canvas id="game" width="384" height="640"></canvas>

    <div class="btnbar" aria-label="ã‚¿ãƒƒãƒ—æ“ä½œ">
      <button id="rotL">â†º</button>
      <button id="left">â†</button>
      <button id="down">â†“</button>
      <button id="right">â†’</button>
      <button id="rotR">â†»</button>
      <button id="drop" class="wide">ç¬é–“è½ä¸‹</button>
    </div>

    <div class="note">
      æ“ä½œï¼šâ† â†’ ç§»å‹• / â†‘ å›è»¢ / â†“ ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ— / ã‚¹ãƒšãƒ¼ã‚¹ ç¬é–“è½ä¸‹ / R ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    </div>
  </div>
</div>

<!-- Overlays -->
<div id="overlay" class="overlay">
  <div class="card" role="dialog" aria-modal="true">
    <h3 id="ovTitle">çµæœ</h3>
    <p id="ovMsg"></p>
    <div class="scores">ãƒ™ã‚¹ãƒˆ: <span id="best1">-</span><span id="best2">-</span><span id="best3">-</span></div>
    <div class="row" style="margin-top:10px">
      <button id="retry">ãƒªãƒˆãƒ©ã‚¤</button>
      <button id="giveUp">è«¦ã‚ã‚‹</button>
      <button id="shareResult">çµæœã‚’Xã§ã‚·ã‚§ã‚¢</button>
    </div>
    <div id="shareAlt" class="note" style="display:none;margin-top:8px"></div>
  </div>
</div>

<script>
(function() {
  'use strict';
  
  // ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ç™»éŒ²
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js')
        .then((registration) => {
          console.log('ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ç™»éŒ²æˆåŠŸ:', registration.scope);
        })
        .catch((error) => {
          console.log('ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ç™»éŒ²å¤±æ•—:', error);
        });
    });
  }

  // ã‚¢ãƒ—ãƒªã‚¢ã‚¤ã‚³ãƒ³èª­ã¿è¾¼ã¿
  const icon = new Image();
  icon.onload = () => {
    const iconElement = document.getElementById('appicon');
    iconElement.src = icon.src;
    iconElement.classList.add('ready');
    console.log('ã‚¢ãƒ—ãƒªã‚¢ã‚¤ã‚³ãƒ³ ketsupoyo.png ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ');
  };
  icon.onerror = () => {
    console.log('ã‚¢ãƒ—ãƒªã‚¢ã‚¤ã‚³ãƒ³ ketsupoyo.png ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆä»»æ„ï¼‰- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã¨PWAã‚¢ã‚¤ã‚³ãƒ³ã«ä½¿ç”¨ã•ã‚Œã¾ã™');
  };
  icon.src = 'ketsupoyo.png';

  // PWAã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆã‚ˆã‚Šç©æ¥µçš„ãªè‡ªå‹•ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼‰
  let deferredPrompt;
  let installPromptShown = false;

  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('PWAã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæº–å‚™å®Œäº†');
    e.preventDefault();
    deferredPrompt = e;
    const installBtn = document.getElementById('installBtn');
    installBtn.style.display = 'inline-flex';
    
    // ã‚ˆã‚Šæ—©ãè‡ªå‹•ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¡¨ç¤ºï¼ˆ2ç§’å¾Œï¼‰
    if (!installPromptShown) {
      setTimeout(() => {
        if (deferredPrompt && !installPromptShown) {
          console.log('è‡ªå‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤º');
          showInstallPrompt();
        }
      }, 2000);
    }
  });

  // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«ã‚‚ãƒã‚§ãƒƒã‚¯
  window.addEventListener('load', () => {
    console.log('ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰å®Œäº†');
    // ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒãªã„å ´åˆã®ä»£æ›¿æ‰‹æ®µ
    if (!deferredPrompt && !installPromptShown) {
      setTimeout(() => {
        if (!installPromptShown) {
          console.log('æ‰‹å‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¡ˆå†…è¡¨ç¤º');
          alert('ğŸ“± ã“ã®ã‚¢ãƒ—ãƒªã‚’ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã§ãã¾ã™ï¼\nãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
          installPromptShown = true;
        }
      }, 3000);
    }
  });

  async function showInstallPrompt() {
    if (deferredPrompt && !installPromptShown) {
      installPromptShown = true;
      try {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        console.log(`ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«çµæœ: ${outcome}`);
        deferredPrompt = null;
      } catch (error) {
        console.log('ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      }
    }
  }

  document.getElementById('installBtn').addEventListener('click', async () => {
    if (deferredPrompt) {
      await showInstallPrompt();
    } else {
      // ã‚ˆã‚Šè©³ç´°ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èª¬æ˜
      const userAgent = navigator.userAgent;
      let instruction = '';
      
      if (userAgent.includes('Chrome')) {
        instruction = 'Chrome: å³ä¸Šãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆâ‹®ï¼‰â†’ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€';
      } else if (userAgent.includes('Safari')) {
        instruction = 'Safari: ç”»é¢ä¸‹éƒ¨ã®å…±æœ‰ãƒœã‚¿ãƒ³ï¼ˆâ–¡â†—ï¼‰â†’ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€';
      } else {
        instruction = 'ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ã‚’é¸æŠã—ã¦ãã ã•ã„';
      }
      
      alert(`ğŸ“± ${instruction}`);
    }
  });

  // UIè¦ç´ 
  const startScreen = document.getElementById('startScreen');
  const gameArea = document.getElementById('gameArea');
  const startBtn = document.getElementById('startBtn');
  const shareXBtn = document.getElementById('shareX');
  const copyUrlBtn = document.getElementById('copyUrl');
  
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // ã‚²ãƒ¼ãƒ è¨­å®š
  const COLS = 6;
  const ROWS = 12;
  const TILE = Math.floor(Math.min(W / COLS, H / ROWS));
  const PX = Math.floor((W - COLS * TILE) / 2);
  const PY = Math.floor((H - ROWS * TILE) / 2);
  const TYPES = 6;
  const COLORS = ['#f5c6a5', '#e0f0ff', '#c6d0ff', '#ffd9d9', '#c0ffc8', '#ffe6a8'];

  // ã¯ã‚€ã‚±ãƒ„ç”»åƒèª­ã¿è¾¼ã¿
  const hamImages = Array.from({length: TYPES}, (_, i) => new Image());
  let useImages = false;
  let loadedImages = 0;

  hamImages.forEach((img, i) => {
    img.onload = () => {
      loadedImages++;
      console.log(`ã¯ã‚€ã‚±ãƒ„ç”»åƒ ${i + 1}/6 èª­ã¿è¾¼ã¿å®Œäº†: assets/ham_${String(i + 1).padStart(2, '0')}.png`);
      if (loadedImages === TYPES) {
        useImages = true;
        console.log('å…¨ã¦ã®ã¯ã‚€ã‚±ãƒ„ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸï¼');
      }
    };
    img.onerror = () => {
      console.log(`ã¯ã‚€ã‚±ãƒ„ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: assets/ham_${String(i + 1).padStart(2, '0')}.pngï¼ˆã‚«ãƒ©ãƒ¼å††ã§ä»£ç”¨ï¼‰`);
    };
    img.src = `assets/ham_${String(i + 1).padStart(2, '0')}.png`;
  });

  // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
  let gameStarted = false;
  let grid;
  let falling;
  let nextPair;
  let score = 0;
  let chain = 0;
  let gameOver = false;
  let timeMode = false;
  let timeLeft = 180000;
  let dropTimer = 0;
  
  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
  let resolving = false;
  let phase = 0;
  let phaseTimer = 0;
  let particles = [];

  // UIè¦ç´ 
  const timeEl = document.getElementById('time');
  const timeWrap = document.getElementById('timeWrap');
  const modeBtn = document.getElementById('mode');

  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´ï¼ˆPCãƒ»ã‚¹ãƒãƒ›å¯¾å¿œï¼‰
  function fit() {
    if (!gameStarted) return;
    
    const availableWidth = window.innerWidth - 16;
    const availableHeight = window.innerHeight - 280;
    
    // PCç”¨ã®æœ€å¤§ã‚µã‚¤ã‚ºåˆ¶é™
    const maxWidth = 500; // PCç”¨æœ€å¤§å¹…
    const maxHeight = 800; // PCç”¨æœ€å¤§é«˜ã•
    
    const scaleByWidth = Math.min(availableWidth, maxWidth) / W;
    const scaleByHeight = Math.min(availableHeight, maxHeight) / H;
    const scale = Math.min(scaleByWidth, scaleByHeight);
    
    // ã‚¹ãƒãƒ›ã§ã¯ç”»é¢å¹…ã®90%ã€PCã§ã¯é©åº¦ãªã‚µã‚¤ã‚ºã«
    const isSmallScreen = window.innerWidth <= 768;
    const finalScale = isSmallScreen ? 
      Math.max(scale, availableWidth / W * 0.9) : 
      Math.max(scale, 0.8);
    
    canvas.style.width = (W * finalScale) + 'px';
    canvas.style.height = (H * finalScale) + 'px';
    
    const btnBar = document.querySelector('.btnbar');
    btnBar.style.maxWidth = (W * finalScale) + 'px';
    btnBar.style.width = (W * finalScale) + 'px';
  }
  window.addEventListener('resize', fit);

  // åŸºæœ¬é–¢æ•°
  function empty() {
    return { type: 0, mark: false, seed: Math.random() * 1000 };
  }

  function resetGrid() {
    return Array.from({ length: ROWS }, () => 
      Array.from({ length: COLS }, empty)
    );
  }

  function randomType() {
    return 1 + Math.floor(Math.random() * TYPES);
  }

  function newPair() {
    return {
      cx: Math.floor(COLS / 2),
      cy: -1,
      blocks: [
        { dx: 0, dy: 0, type: randomType() },
        { dx: 0, dy: -1, type: randomType() }
      ],
      rot: 0
    };
  }

  function restart() {
    grid = resetGrid();
    score = 0;
    chain = 0;
    gameOver = false;
    dropTimer = 0;
    resolving = false;
    phase = 0;
    phaseTimer = 0;
    particles = [];
    
    falling = newPair();
    nextPair = newPair();
    
    updateHUD();
    hideOverlay();
  }

  function updateHUD() {
    document.getElementById('score').textContent = score;
    document.getElementById('chain').textContent = chain;
  }

  // ç§»å‹•å¯èƒ½åˆ¤å®š
  function canMove(pair, dx, dy) {
    for (const block of pair.blocks) {
      const x = pair.cx + block.dx + dx;
      const y = pair.cy + block.dy + dy;
      
      if (x < 0 || x >= COLS || y >= ROWS) {
        return false;
      }
      
      if (y >= 0 && grid[y][x].type) {
        return false;
      }
    }
    return true;
  }

  // å›è»¢å¾Œã®ä½ç½®
  function getRotatedBlocks(rot, type0, type1) {
    const block0 = { dx: 0, dy: 0, type: type0 };
    const block1 = { dx: 0, dy: -1, type: type1 };
    
    if (rot === 1) { block1.dx = 1; block1.dy = 0; }
    if (rot === 2) { block1.dx = 0; block1.dy = 1; }
    if (rot === 3) { block1.dx = -1; block1.dy = 0; }
    
    return [block0, block1];
  }

  // æ“ä½œé–¢æ•°
  function moveLeft() {
    if (!falling || gameOver || resolving) return;
    if (canMove(falling, -1, 0)) {
      falling.cx -= 1;
    }
  }

  function moveRight() {
    if (!falling || gameOver || resolving) return;
    if (canMove(falling, 1, 0)) {
      falling.cx += 1;
    }
  }

  function softDrop() {
    if (!falling || gameOver || resolving) return;
    if (canMove(falling, 0, 1)) {
      falling.cy += 1;
    } else {
      lockPiece();
    }
  }

  function hardDrop() {
    if (!falling || gameOver || resolving) return;
    while (canMove(falling, 0, 1)) {
      falling.cy += 1;
    }
    lockPiece();
  }

  function rotate() {
    if (!falling || gameOver || resolving) return;
    
    const nextRot = (falling.rot + 1) % 4;
    const newBlocks = getRotatedBlocks(
      nextRot, 
      falling.blocks[0].type, 
      falling.blocks[1].type
    );
    
    const tempPair = {
      ...falling,
      blocks: newBlocks,
      rot: nextRot
    };
    
    if (canMove(tempPair, 0, 0)) {
      falling.blocks = newBlocks;
      falling.rot = nextRot;
    }
  }

  // ãƒ”ãƒ¼ã‚¹å›ºå®š
  function lockPiece() {
    // å„ãƒ–ãƒ­ãƒƒã‚¯ã‚’å€‹åˆ¥ã«é…ç½®ï¼ˆãƒšã‚¢ã®é€£çµã‚’å®Œå…¨ã«è§£é™¤ï¼‰
    for (const block of falling.blocks) {
      const x = falling.cx + block.dx;
      const y = falling.cy + block.dy;
      
      if (y < 0) {
        gameOverNow('ä¸Šã¾ã§ç©ã¿ä¸ŠãŒã‚Šã¾ã—ãŸâ€¦');
        return;
      }
      
      // å®Œå…¨ã«ç‹¬ç«‹ã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦é…ç½®
      grid[y][x] = { 
        type: block.type, 
        mark: false, 
        seed: Math.random() * 1000 // å„ãƒ–ãƒ­ãƒƒã‚¯ç‹¬è‡ªã®seed
      };
    }
    
    falling = null;
    resolving = true;
    phase = 0;
    phaseTimer = 0;
  }

  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†
  function processResolving() {
    phaseTimer += 16;
    
    if (phase === 0) {
      scanForMatches();
    } else if (phase === 1) {
      if (phaseTimer >= 500) {
        phase = 2;
        phaseTimer = 0;
      }
    } else if (phase === 2) {
      // æ¶ˆå»ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆ300msï¼‰
      if (phaseTimer >= 300) {
        clearMarkedBlocks();
        dropBlocks();
        
        // å°‘ã—å¾…ã£ã¦ã‹ã‚‰æ¬¡ã®ã‚¹ã‚­ãƒ£ãƒ³
        phase = 0;
        phaseTimer = 0;
        setTimeout(() => {
          if (resolving) {
            scanForMatches();
          }
        }, 150);
      }
    }
  }

  function scanForMatches() {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        grid[r][c].mark = false;
      }
    }

    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    let totalCleared = 0;

    function floodFill(startR, startC) {
      const type = grid[startR][startC].type;
      const queue = [[startR, startC]];
      const cells = [[startR, startC]];
      visited[startR][startC] = true;

      while (queue.length > 0) {
        const [r, c] = queue.shift();
        
        for (const [dr, dc] of directions) {
          const nr = r + dr;
          const nc = c + dc;
          
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS &&
              !visited[nr][nc] && grid[nr][nc].type === type) {
            visited[nr][nc] = true;
            queue.push([nr, nc]);
            cells.push([nr, nc]);
          }
        }
      }
      
      return cells;
    }

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!visited[r][c] && grid[r][c].type) {
          const cells = floodFill(r, c);
          if (cells.length >= 4) {
            totalCleared += cells.length;
            cells.forEach(([rr, cc]) => {
              grid[rr][cc].mark = true;
              spawnBurst(PX + cc * TILE + TILE / 2, PY + rr * TILE + TILE / 2, grid[rr][cc].type);
            });
          }
        }
      }
    }

    if (totalCleared > 0) {
      phase = 1;
      phaseTimer = 0;
      chain++;
    } else {
      resolving = false;
      falling = nextPair;
      nextPair = newPair();
      
      let hasBlocks = false;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c].type) {
            hasBlocks = true;
            break;
          }
        }
        if (hasBlocks) break;
      }
      
      if (!hasBlocks) {
        clearNow();
      }
      
      updateHUD();
    }
  }

  function clearMarkedBlocks() {
    let clearedCount = 0;
    
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (grid[r][c].mark) {
          grid[r][c] = empty();
          clearedCount++;
        }
      }
    }
    
    if (clearedCount > 0) {
      const points = clearedCount * 10 * (chain > 1 ? chain : 1);
      score += points;
      updateHUD();
    }
  }

  // ãƒ–ãƒ­ãƒƒã‚¯è½ä¸‹ï¼ˆé‡åŠ›å‡¦ç†ï¼‰- å€‹åˆ¥ãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œ
  function dropBlocks() {
    let hasMoved = false;
    
    // å„ãƒ–ãƒ­ãƒƒã‚¯ã‚’å€‹åˆ¥ã«å‡¦ç†ï¼ˆãƒšã‚¢ã®é€£çµã‚’è§£é™¤ï¼‰
    for (let c = 0; c < COLS; c++) {
      for (let r = ROWS - 2; r >= 0; r--) { // æœ€ä¸‹æ®µã¯é™¤ã
        if (grid[r][c].type !== 0 && grid[r + 1][c].type === 0) {
          // 1ã¤ä¸‹ã«è½ã¨ã™ï¼ˆå€‹åˆ¥ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦ï¼‰
          grid[r + 1][c] = { 
            type: grid[r][c].type, 
            mark: false, 
            seed: Math.random() * 1000 // æ–°ã—ã„seedã§å€‹åˆ¥åŒ–
          };
          grid[r][c] = empty();
          hasMoved = true;
        }
      }
    }
    
    // ã¾ã è½ã¡ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚Œã°å†å¸°çš„ã«å‡¦ç†
    if (hasMoved) {
      setTimeout(() => dropBlocks(), 50);
    }
  }

  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
  function spawnBurst(x, y, type) {
    const numParticles = 12;
    for (let i = 0; i < numParticles; i++) {
      const angle = (Math.PI * 2 * i) / numParticles;
      const speed = 3 + Math.random() * 4;
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 2,
        life: 0,
        maxLife: 600 + Math.random() * 400,
        type,
        size: TILE * (0.3 + Math.random() * 0.2)
      });
    }
  }

  function updateParticles(dt) {
    const gravity = 0.015;
    
    particles.forEach(p => {
      p.life += dt;
      p.x += p.vx * dt * 0.1;
      p.y += p.vy * dt * 0.1;
      p.vy += gravity * dt;
    });
    
    particles = particles.filter(p => p.life < p.maxLife);
  }

  // æç”»
  function drawBlob(x, y, size, type, alpha = 1, shakeX = 0, shakeY = 0, scale = 1) {
    ctx.save();
    ctx.globalAlpha = alpha;
    
    const cx = x + size / 2 + shakeX;
    const cy = y + size / 2 + shakeY;
    
    if (scale !== 1) {
      ctx.translate(cx, cy);
      ctx.scale(scale, scale);
      ctx.translate(-cx, -cy);
    }
    
    // ã¯ã‚€ã‚±ãƒ„ç”»åƒãŒã‚ã‚Œã°ç”»åƒã‚’è¡¨ç¤ºã€ãªã‘ã‚Œã°å††ã‚’è¡¨ç¤º
    if (useImages && hamImages[type - 1] && hamImages[type - 1].complete) {
      ctx.drawImage(hamImages[type - 1], x + shakeX, y + shakeY, size, size);
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šã‚«ãƒ©ãƒ¼å††
      const r = size * 0.45;
      
      const grad = ctx.createRadialGradient(
        cx - r * 0.4, cy - r * 0.4, r * 0.2,
        cx, cy, r
      );
      const base = COLORS[(type - 1) % COLORS.length];
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.15, base);
      grad.addColorStop(1, '#333');
      
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.beginPath();
      ctx.arc(cx + r * 0.3, cy - r * 0.2, r * 0.15, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }

  function drawParticles() {
    for (const p of particles) {
      const alpha = Math.max(0, 1 - (p.life / p.maxLife));
      const size = p.size * alpha;
      
      ctx.save();
      ctx.globalAlpha = alpha;
      
      // ã¯ã‚€ã‚±ãƒ„ç”»åƒãŒã‚ã‚Œã°å°ã•ãªç”»åƒã€ãªã‘ã‚Œã°å††
      if (useImages && hamImages[p.type - 1] && hamImages[p.type - 1].complete) {
        const imgSize = size * 0.3;
        ctx.drawImage(hamImages[p.type - 1], p.x - imgSize/2, p.y - imgSize/2, imgSize, imgSize);
      } else {
        ctx.fillStyle = COLORS[(p.type - 1) % COLORS.length];
        ctx.beginPath();
        ctx.arc(p.x, p.y, size * 0.15, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
  }

  function draw() {
    if (!gameStarted) return;
    
    ctx.fillStyle = '#0f1220';
    ctx.fillRect(0, 0, W, H);
    
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.fillRect(PX + c * TILE + 1, PY + r * TILE + 1, TILE - 2, TILE - 2);
      }
    }
    
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cell = grid[r][c];
        if (cell.type) {
          let alpha = 1, shakeX = 0, shakeY = 0, scale = 1;
          
          if (cell.mark) {
            if (phase === 1) {
              const amp = TILE * 0.1;
              const t = (phaseTimer + cell.seed * 15) * 0.02;
              shakeX = Math.sin(t) * amp;
              shakeY = Math.cos(t * 1.3) * amp;
            } else if (phase === 2) {
              const progress = phaseTimer / 300;
              scale = 1 + progress * 0.5;
              alpha = 1 - progress * 0.8;
            }
          }
          
          drawBlob(PX + c * TILE, PY + r * TILE, TILE, cell.type, alpha, shakeX, shakeY, scale);
        }
      }
    }
    
    if (falling) {
      for (const block of falling.blocks) {
        const x = falling.cx + block.dx;
        const y = falling.cy + block.dy;
        if (y >= 0) {
          drawBlob(PX + x * TILE, PY + y * TILE, TILE, block.type);
        }
      }
    }
    
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.strokeRect(PX - 1, PY - 1, COLS * TILE + 2, ROWS * TILE + 2);
    
    drawParticles();
  }

  // æ›´æ–°
  function update(dt) {
    if (!gameStarted || gameOver) return;

    updateParticles(dt);

    if (resolving) {
      processResolving();
      return;
    }

    dropTimer += dt;
    const fallInterval = Math.max(150, 800 - Math.floor(score / 200) * 30);
    
    if (dropTimer >= fallInterval) {
      dropTimer = 0;
      if (falling) {
        softDrop();
      }
    }

    if (timeMode) {
      timeLeft -= dt;
      if (timeLeft <= 0) {
        gameOverNow('æ™‚é–“åˆ‡ã‚Œâ€¦');
        return;
      }
      timeEl.textContent = Math.max(0, Math.ceil(timeLeft / 1000));
    }
  }

  // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
  function loop(now) {
    const dt = now - (loop.last || now);
    loop.last = now;
    
    update(dt);
    draw();
    
    requestAnimationFrame(loop);
  }

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['ArrowUp', 'Space', 'KeyR'].includes(e.code)) {
      e.preventDefault();
    }
  });
  
  window.addEventListener('keyup', e => {
    if (keys[e.code]) {
      keys[e.code] = false;
      
      if (e.code === 'ArrowLeft') moveLeft();
      if (e.code === 'ArrowRight') moveRight();
      if (e.code === 'ArrowDown') softDrop();
      if (e.code === 'ArrowUp') rotate();
      if (e.code === 'Space') hardDrop();
      if (e.code === 'KeyR') restart();
    }
  });

  // ãƒœã‚¿ãƒ³æ“ä½œ
  function bindButton(id, fn, repeat = true) {
    const el = document.getElementById(id);
    if (!el) return;
    
    let timer;
    
    const press = () => {
      fn();
      if (repeat) {
        timer = setInterval(fn, 120);
      }
    };
    
    const release = () => {
      clearInterval(timer);
    };
    
    el.addEventListener('touchstart', e => {
      e.preventDefault();
      press();
    });
    
    el.addEventListener('touchend', e => {
      e.preventDefault();
      release();
    });
    
    el.addEventListener('mousedown', press);
    el.addEventListener('mouseup', release);
    el.addEventListener('mouseleave', release);
  }

  bindButton('left', moveLeft);
  bindButton('right', moveRight);
  bindButton('down', softDrop);
  bindButton('rotL', rotate);
  bindButton('rotR', rotate);
  bindButton('drop', hardDrop, false);

  // åˆ¶é™æ™‚é–“ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
  modeBtn.addEventListener('click', () => {
    timeMode = !timeMode;
    if (timeMode) {
      timeLeft = 180000;
      timeWrap.style.display = 'inline';
      modeBtn.textContent = 'åˆ¶é™æ™‚é–“:ON';
    } else {
      timeWrap.style.display = 'none';
      modeBtn.textContent = 'åˆ¶é™æ™‚é–“:OFF';
    }
  });

  // ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ
  startBtn.addEventListener('click', () => {
    startScreen.style.display = 'none';
    gameArea.classList.add('active');
    gameStarted = true;
    fit();
    restart();
    requestAnimationFrame(loop);
  });

  // Xã‚·ã‚§ã‚¢ãƒœã‚¿ãƒ³
  shareXBtn.addEventListener('click', () => {
    const text = encodeURIComponent('ã¯ã‚€ã‚±ãƒ„ã½ã‚ˆã½ã‚ˆã§éŠã‚“ã§ã¿ã¦ã­ï¼ğŸ¹âœ¨\nã¯ã‚€ã‚±ãƒ„ã‚’4å€‹ä»¥ä¸Šã¤ãªã’ã¦ã€ã·ã‚‹ã·ã‚‹æ¶ˆã™ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ \n\n#ã¯ã‚€ãƒãƒ© #ã¯ã‚€ã‚±ãƒ„ã½ã‚ˆã½ã‚ˆ');
    const url = encodeURIComponent('https://hamuchiranagaya.github.io/ketsu-poyo/');
    window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
  });

  // URLã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³
  copyUrlBtn.addEventListener('click', async () => {
    const gameUrl = 'https://hamuchiranagaya.github.io/ketsu-poyo/';
    try {
      await navigator.clipboard.writeText(gameUrl);
      copyUrlBtn.innerHTML = '<span>âœ…</span><span>ã‚³ãƒ”ãƒ¼å®Œäº†</span>';
      setTimeout(() => {
        copyUrlBtn.innerHTML = '<span>ğŸ“‹</span><span>URLã‚³ãƒ”ãƒ¼</span>';
      }, 2000);
    } catch (err) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      const textArea = document.createElement('textarea');
      textArea.value = gameUrl;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      copyUrlBtn.innerHTML = '<span>âœ…</span><span>ã‚³ãƒ”ãƒ¼å®Œäº†</span>';
      setTimeout(() => {
        copyUrlBtn.innerHTML = '<span>ğŸ“‹</span><span>URLã‚³ãƒ”ãƒ¼</span>';
      }, 2000);
    }
  });

  // ã‚¹ã‚³ã‚¢ç®¡ç†
  function loadScores() {
    try {
      return JSON.parse(localStorage.getItem('ham_poyo_scores') || '[]');
    } catch {
      return [];
    }
  }

  function saveScore(sc) {
    const arr = loadScores();
    arr.push({ s: sc, t: Date.now() });
    arr.sort((a, b) => b.s - a.s);
    const top = arr.slice(0, 3);
    localStorage.setItem('ham_poyo_scores', JSON.stringify(top));
    return top;
  }

  function showBest() {
    const arr = loadScores();
    const bestEls = [
      document.getElementById('best1'),
      document.getElementById('best2'),
      document.getElementById('best3')
    ];
    bestEls.forEach((el, i) => {
      el.textContent = arr[i] ? arr[i].s : '-';
    });
  }

  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
  function showOverlay(title, msg) {
    const overlay = document.getElementById('overlay');
    const ovTitle = document.getElementById('ovTitle');
    const ovMsg = document.getElementById('ovMsg');
    
    ovTitle.textContent = title;
    ovMsg.textContent = msg;
    showBest();
    overlay.style.display = 'flex';
  }

  function hideOverlay() {
    const overlay = document.getElementById('overlay');
    overlay.style.display = 'none';
  }

  function gameOverNow(reason) {
    gameOver = true;
    saveScore(score);
    showOverlay('Game Over', `${reason} ã‚¹ã‚³ã‚¢: ${score}`);
  }

  function clearNow() {
    gameOver = true;
    saveScore(score);
    showOverlay('ã‚¯ãƒªã‚¢ï¼', `å…¨éƒ¨æ¶ˆã—ã¾ã—ãŸï¼ ã‚¹ã‚³ã‚¢: ${score}`);
  }

  function backToStart() {
    gameStarted = false;
    gameArea.classList.remove('active');
    startScreen.style.display = 'block';
    hideOverlay();
  }

  // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  document.getElementById('retry').addEventListener('click', () => {
    restart();
  });
  
  document.getElementById('giveUp').addEventListener('click', () => {
    backToStart();
  });

  document.getElementById('shareResult').addEventListener('click', async () => {
    const text = encodeURIComponent(`ã¯ã‚€ã‚±ãƒ„ã½ã‚ˆã½ã‚ˆã§ã‚¹ã‚³ã‚¢ ${score} ç‚¹ã‚’è¨˜éŒ²ï¼ğŸ¹âœ¨\nã¯ã‚€ã‚±ãƒ„ã‚’4å€‹ä»¥ä¸Šã¤ãªã’ã¦ã€ã·ã‚‹ã·ã‚‹æ¶ˆã™ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ \n\n#ã¯ã‚€ãƒãƒ© #ã¯ã‚€ã‚±ãƒ„ã½ã‚ˆã½ã‚ˆ`);
    const url = encodeURIComponent('https://hamuchiranagaya.github.io/ketsu-poyo/');
    window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
  });

  // åˆæœŸåŒ–
  fit();
})();
</script>
</body>
</html>